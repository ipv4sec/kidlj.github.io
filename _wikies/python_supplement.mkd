---
title: Python Supplement
---

记录我所读的 Python 教材书中没有涉及到的知识和技巧。


### 任意长度参数

调用 `print` 函数时可以有不同数量的参数，我们也可以定义这样的函数：

	def func(positional, keyword = parameter1, *args):

定义函数时，`*args` 应作为最后一个参数。调用该函数，Python 会将该位置的所有参数收集为一个元组。

### 从序列中解包参数

跟上一技巧过程相反，我们可以从列表或元组中解包参数来供函数使用：

	>>> args = [3, 6]
	>>> list(range(*args))
	[3, 4, 5]

	>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
	>>> list(zip(*matrix))
	[(1, 4, 7), (2, 5, 8), (3, 6, 9)]


### Lambda

可以用 `lambda` 关键字来定义一个简短的匿名函数，它的格式为：

	lambda parameters: expression

- `lambda` 可以用于所有需要一个函数对象的地方，比如嵌套函数：

		>>> def make_incrementor(n):
				return lambda x: x + n
		>>> f = make_incrementor(43)
		>>> f(0)
		42
		>>> f(1)
		43

	这等价于：

		def make_incrementor(n):
			def f(x):
				return x + n
			return f

- 用于列表的排序

		>>> pairs = [(1, "one"), (2, "two"), (3, "three"), (4, "four)]
		>>> sorted(pairs, key=lambda pair: pair[1])
		[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
		>>> pairs.sort(key=lambda pair: pair[1])
		>>> pairs
		[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]


### 列表

- 分片赋值

		>>> a = ['a', 'b', 'c', 'd', 'e']
		>>> a[1: 3] = ['B', 'C']
		>>> a
		['a', 'B', 'C', 'd', 'e']

- 方法

	`list.append(x)` 等价于 `a[len(a) : ] = [x]`;  
	`list.extend(L)` 等价于 `a[len(a) : ] = L` 

- 用作栈或者队列

	列表很适合用作栈，直接使用 `append` 和 `pop` 方法即可。  
	列表不适合用作队列，因为将列表第一个元素移除需要将其它元素全部左移。


### 嵌套的列表推导式

列表推导式里的表达式可以是另一个列表推导式，是为嵌套列表推导式：

	>>> matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
	>>> [[row[i] for row in matrix] for i in range(4)]
	[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

注意和下边这个列表推导式区分：
	
	>>> [row[i] for row in matrix for i in range(4)]
	[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]


### 元组

元组打包：

	t = 1, 2, 3

初始化一个空元组：

	t = ()

初始化只有一个元素的元组：

	t = ('hello',)	# ``,`` 是必需的
	t = ('hello')	# 这样是不对的

如果一个元组包含可变对象，那么这个元组是非 hashable 的：

	>>> {(1, [2, 3]): 'test'}
	TypeError: unhashable type: 'list'


### 序列解包

任何序列都支持序列解包操作：

	>>> t = (1, 2, 3)
	>>> x, y, z = t

实际上，多重赋值就是一种元组打包和序列解包的结合：

	>>> x, y, z = 1, 2, 3
	

### 字典

- 构造器

	可以用 `dict()` 从元素为 "key, value" 结构的序列中方便地构建字典：

		>>> dict([[1, 'one'], (2, 'two')])
		{1: 'one', 2: 'two'}

	也可以用 keyword arguments 来构建字典：

		>>> dict(language="Python", platform="Linux")
		{'platform': 'Linux', 'language': 'Python'}


- 字典推导式

	跟列表推导式相似：

		>>> {x: x**2 for x in (2, 4, 6)}
		{2: 4, 4: 16, 6: 36}


### 迭代技巧

并行迭代：

	>>> truth = {'Python 2': 'the good', 'Python 3', 'the best'}
	>>> for k, v in truth.items():
	...		print(k, v)
	...
	Python 2 the good
	Python 3 the best

当迭代一个序列，可以用 `enumerate` 函数来一同获取位置索引：

	>>> for i, v in enumerate(['a', 'b', 'c']):
    ...		print(i, v)
	...
	0 a
	1 b
	2 c

当同时迭代两个或多个序列，可以用 `zip()` 函数将序列元素配对：

	>>> questions = ['name', 'website', 'favorite color']
	>>> answers = ['me', 'kidlj.com', 'cyan']'
	>>> for q, a in zip(questions, answers):
    ...		print("What is your {0}? It is {1}".format(q, a))
	...
	What is your name? It is me
	What is your website? It is kidlj.com
	What is your favorite color? It is cyan

反向迭代：

	>>> for i in reversed(range(3)):
	...		print(i)
	...
	2
	1
	0

先排序再迭代, `sorted()`会返回一个新列表：

	>>> letters = ['a', 'c', 'd', 'b', 'g', 'e']
	>>> for i in sorted(set(letters)):
	...		print(i)
	...
	['a', 'c', 'd', 'b', 'g', 'e']

如果迭代过程中要改变迭代对象，那么应该先拷贝一份迭代对象：

	>>> words = ['apple', 'banana', 'favoritefruit']
	>>> for word in words[:]:
	...		if len(word) > 6:
	...			words.insert(0, word)
	...
	>>> words
	['favoritefruit', 'apple', 'banana', 'favoritefruit']

	
