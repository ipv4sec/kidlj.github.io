---
title: Shell
---



变量
====

### 引用、类型与命名规则

引用一个变量必须在前面加上`$`：比如`echo $PATH`；还有一种更正式的引用方式为`${PATH}`。

引用一个未定义（赋值）的变量不会抛出错误，没有被赋值的变量为空字符串。

Shell 变量没有“类型”的概念，如果一定要说类型，那么任何变量都是字符串。但有些函数在处理字符串时会将其中包含的数字字符当成数值来处理，这为 Shell 的数学运算提供了便利。

通常而言，包含常数、字符串以及文件名等内容的变量使用大写，而包含数字、用户输入或其他“数据”的变量则使用小写。

### 赋值

对变量赋值的方式主要有三种：

1. 显式定义：`VAR=value`

	等于号两边不允许有空格。像`VAR = value`，`VAR =value`以及`VAR= value`都不是赋值语句，而有着各自的含义。`VAR = value`被当成带有两个参数的命令`VAR`，参数是`=`和`value`；`VAR =value`同理。`VAR= value`是指在执行`value`命令的时候将`VAR`变量赋值为空。

2. 读取：`read VAR`

	一次读入一个变量：
		
		echo -n "Enter you name: "
		read name
		echo "Hello $name."
		
	一次读入多个变量：

		echo -n "Please enter your first name and last name: "
		read firstname lastname
		echo "Hello, $firstname. How is the $lastname family?"

	用一个变量从文件中读入一行：

		read message < /var/lib/portage/world
		echo $message

	用一个变量输出整个文件，每次打印一行：

		while read message
		do
			echo $message
			sleep 0.5
		done < /var/lib/portage/world

	（注：如果读取到文件末尾，`read`会返回非零值，于是 while 循环就会停止。）

3. 命令替换：`VAR=$(date)`

	这是第一种赋值方式`VAR=value`的变种。

		TODAY=$(date +%A)
		echo "Today is $TODAY."

	还有一种更通用的命令替换格式，原始的 Bourne Shell 只支持这种：

		TODAY=`date +%A`

### 删除变量

可以用`unset`命令删除一个变量：

	$ unset var

或者直接将变量赋值为空：

	$ var=

不过这两者本质上不相同的。后者虽然将变量赋值为空，但其仍然存在；而`unset`命令会真正的删除一个变量。


高级变量操作
===========

### 字符串裁剪

1. 按照长度裁剪变量字符串

		$ variable="foobar"

		$ echo ${variable:3}
		bar
		$ echo ${variable:3:2}
		ba

		$ echo {variable: -4}
		obar

2. 使用模式裁剪字符串

		$ phone="185-1111-2222"

		$ echo ${phone#*-}
		1111-2222
		$ echo ${phone##*-}
		2222

		$ echo {phone%-*}
		185-1111
		$ echo {phone%%-*}
		185

### 变量字符串的长度

可以获取一个变量的字符串长度：

	$ var="Test"
	$ echo ${#var}
	4

### 大小写转换

可以将变量内容转为全部大写或者小写：

	$ var="Test"
	$ echo ${var^^}
	TEST
	$ echo ${var,,}
	test

### 提供缺省值

在引用变量时，为避免变量值为空，可以为其指定缺省值：

	$ ${EDITOR:-/usr/bin/vim} "$myfile"
	$ ${EDITOR:-`which vim`} "$myfile"

可能每次都这样做会比较麻烦，可以在指定变量缺省值的同时将其赋值：

	$ ${EDITOR:=/usr/bin/vi} "$myfile1"
	$ ${EDITOR} "$myfile2"

### 基于变量存在的操作

如果一个变量有值（即使被赋为空值），则可基于此做一些有趣的事情：

	$ VILOVER=yes
	$ ${VILOVER+"vi"} "$file"

此时将会启动`vi`程序编辑`$file`文件。

### 间接变量

运行如下代码：

	$ for myvar in PATH HOSTNAME; do echo $myvar is ${!myvar}; done

结果返回：

	PATH is /sbin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/bin:/bin
	HOSTNAME is collie

到底是什么意思就自己想吧 :-) 


### 字符串查找与替换

Sed 工具提供了强大的文本查找替换功能，除了调用 sed 以外，Shell 本身也具有基本的查找和替换功能。

准备数据至变量：

	$ user=`grep mellon /etc/passwd`
	
可以只替换第一个和全局替换：
	
	$ echo ${user/mellon/collie}
	$ echo ${user//mellon/collie}

也可以指定模式匹配是在开头还是结尾。正则表达式用`^mellon`表示处在开头处    的匹配，而 Shell 不使用正则表达式，分别用`#`和`%`来表示头部和尾部的模式    匹配：

	$ echo ${user/^mellon/collie}
	$ echo ${user/%bash/csh}

这里也可以使用 Shell 通配符来匹配查询：

	$ echo ${user/me??on/collie}

如果省略掉要替换进来的内容，则将删除匹配的文本：

	$ echo ${user/mellon}
	$ echo ${user//mellon}
	$ echo ${user/#mellon}


数学运算
========

虽然 Shell 变量始终被存储为字符串，但是可以用一些方法使它能像数字一样运算。

1. `let`命令可以直接执行基本的算术操作。

	例如：
	
		let result=$no1+$no2
		echo $result

	自加自减操作：

		$ let no1++
		$ let no2--

	简写形式：

		let no+=6
		let no*=4

2. 还可以用`$(( ))`和`expr`来进行算术运算。

	例如：

		result=$(($no1 + $no2))
		result=`expr 3 + $no1`

3. 使用`let`和`$(( ))`，当期望一个数值时，非数值被当成0。而`expr`则会报错。

	例如：

		$ x=hello
		$ y=2

		$ echo $(($x + $y))
		2

		$ let z=$x+$y
		$ echo $z
		2

		$ expr $x + $y
		expr: non-integer argument

	注：以上这些方法只能用于整数运算，而不支持浮点数。



文件描述符与重定向
=================

### 重定向

显示当前命令打开的文件：

	$ ls -l /proc/self/fd/

显示当前 Shell 打开的文件：

	$ ls -l /proc/$$/fd

分别将`stdout`和`stderr`重定向：

	$ ls -l /home /nosuchfile 1> /tmp/stdout.txt 2> tmp/stderr.txt

同时将`stdout`和`stderr`重定向到一个文件：

	$ ls -l /home /nosuchfile > /tmp/output.txt 2>&1
	$ ls -l /home /nosuchfile >& /tmp/output.txt

输出`stdout`和`stderr`的同时，将`stdout`重定向到一个文件：

	$ ls -l /home /nosuchfile | tee output.txt | cat 

将文件重定向到命令：

	$ read message < /var/lib/portage/world

### 自定义文件描述符

使用`exec`创建用于写操作的文件描述符：

	$ exec 3> /tmp/testing
	$ echo hello >&3

使用`exec`创建用于读操作的文件描述符：

	$ exec 4< /tmp/testing
	$ cat <&4

注：连续对`&3`执行写操作会对文本进行追加，而不是覆盖，因而向文件描述符进行写操作更像是对打印机进行写操作；对文件描述符`&4`读取会消耗输入，这与对常规文件进行读取不同， Shell 会记录文件描述符的当前位置指针，再次读取`&4`只会输出指针后面的新增内容。（暂时也不知`exec`重定向有什么应用场景。）

### 管道

管道将前一个进程的`stdout`连接到另一个进程的`stdin`，而`stderr`仍然输出到终端或者可以重定向到文件：

	$ find / -print | grep hosts

该命令会混合输出`grep hosts`的结果以及`find`命令的错误。可以将`find`命令的`stderr`提前重定向：

	$ find / -print 2> /dev/null | grep hosts


正则表达式与引用
===============

正则表达式与 shell 没有直接关系，只有像 grep, sed, awk 这样的外部命令才使用正则表达式。但因为 shell 扩展和正则表达式使用的语法非常相似，所以从 shell 传递给外部命令的正则表达式可能会在中途被 shell 分析。这一问题可以使用各种引用技术来避免。

有三种主要形式的引用—— 单引号、双引号以及反斜线。

### 单引号

最简单的是单引号，它可以防止 shell 解释其中的内容。Shell 分析的只是与第一个单引号配对的下一个单引号。

### 双引号

用双引号引用，有部分字符会被 shell 解释。变量被解释，但文件名不会被扩展。

双引号中的单引号也被保留。

### 反斜线

当需要在常规字符串中包含特殊字符，但它又会被 shell 解释的时候，我们可以在字符前加上反斜线。

	$ echo "Wilde said, \"Experience is one thing you can't get for\
	 nothing.\""

在双引号中，反斜线起转义作用；在单引号中不起转义作用。
	

数组
====

### 数组的赋值

	numberarray[0]=zero
	numberarray[1]=one
	numberarray[3]=three

	students=( Dave Jennifer Michael Lucy Richard )

	nonprint=( [0]=NUL [1]=SOH [2]=STX [4]=EOT )

	stat=( `cat /proc/$$/stat` )

	mp3s=( *.mp3 )

	read -a arrayname

	IFS=: read -a userdetails < /etc/passwd

	readarray -n 4 -s 2 food

	































